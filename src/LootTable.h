
#pragma once

#include "Item.h"
#include "json/json.h"
#include "Noise/Noise.h"
#include "LootTableParser.h"

/*
This is a representation of the loot tables as described in the wiki:
https://minecraft.gamepedia.com/Loot_table
The json files are parsed every time on startup. Mostly the interpretation is done on loading.
The functions and conditions still contain some Json objects. It was the most effective way to store the parameters.
Notes:
	01.09.2020:
		Vanilla Minecraft uses a luck value per player that influences the outcome.
		This is not added to cuberite at the moment.
		I noted where you need to add some code (search for: "TODO: Luck")
	06.09.2020:
		When updating the loot tables you have to check the Tag interpretation. There might be new items added.
		There is a link to the list in the minecraft wiki in the LootTable class.
*/

// fwd:
class cWorld;
class cBlockHandler;
class cBlockEntity;


/** A individual loot table */
class cLootTable
{
public:
	/** Creates a empty loot table */
	cLootTable() = default;

	/** Creates new loot table from a Json object describing the loot table */
	cLootTable(const Json::Value & a_Description);

	cLootTable(const cLootTable & a_Other) = default;
	cLootTable(cLootTable && a_Other) = default;
	cLootTable & operator = (const cLootTable & a_Other) = default;
	cLootTable & operator = (cLootTable && a_Other) = default;

	/** Fills the specified item grid. Needs world and pos for randomisation and access to player. */
	bool FillWithLoot(cItemGrid & a_ItemGrid, cWorld & a_World, const Vector3i a_Pos, const UInt32 a_PlayerID) const;

	// Note: For any function killed describes the entity which triggered the event. And Killer the entity which killed the entity (if applicable)
	/** Returns cItems with all the items generated by the loot table */
	cItems GetItems(const cNoise & a_Noise, const Vector3i & a_Pos, cWorld & a_World, UInt32 a_KilledID, UInt32 a_KillerID) const;

protected:
	/** contained loot pools */
	LootTable::cLootTablePools m_LootTablePools;

	/** Vector of functions applied to all pools */
	LootTable::cLootTableFunctions m_Functions;

private:
	static cItems GetItems(const LootTable::cLootTablePool & a_Pool, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	static cItems GetItems(const LootTable::cLootTablePoolEntry & a_Entry, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	static bool ConditionsApply(const LootTable::cLootTableConditions & a_Conditions, cWorld & a_World, const cNoise & a_Noise, const Vector3i a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	static bool ConditionApplies(const LootTable::cLootTableCondition & a_Condition, cWorld & a_World, const cNoise & a_Noise, const Vector3i a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	/** Applies give function to item for all types */
	static void ApplyCommonFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	/** Applies given function to an item in a Container */
	static void ApplyFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	/** Applies given function to an item dropped from a block */
	static void ApplyFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const cBlockHandler & a_Block, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	/** Applies given function to an item dropped from a block entity */
	static void ApplyFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const cBlockEntity & a_BlockEntity, const cNoise & a_Noise, const Vector3i & a_Pos, UInt32 a_KilledID, UInt32 a_KillerID);

	/** Applies given function to an item dropped from a killed entity */
	static void ApplyFunction(const LootTable::cLootTableFunction & a_Function, cItem & a_Item, cWorld & a_World, const Vector3i & a_Pos, UInt32 a_KilledID, const cNoise & a_Noise, UInt32 a_KillerID);
};
typedef std::unordered_map<AString, cLootTable> cLootTables;




